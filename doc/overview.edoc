			-*- html -*-

	EUnit overview page

@title EUnit - a Lightweight Unit Testing Framework for Erlang

@author Richard Carlsson <richardc@it.uu.se>
        [http://user.it.uu.se/~richardc/]
@author Mickaël Rémond <mickael.remond@process-one.net> 
        [http://www.process-one.net/]
@copyright 2004-2006 Mickaël Rémond, Richard Carlsson
@version {@vsn}, {@date} {@time}

@doc EUnit is a unit testing framework for Erlang. It is very powerful
and flexible, but is easy to use and has small syntactical overhead.

<ul>
<li>{@section Unit Testing}</li>
<li>{@section Terminology}</li>
<li>{@section Getting started}</li>
<li>{@section EUnit macros}</li>
</ul>

EUnit builds on ideas from the family of unit testing frameworks for
Object Oriented languages that originated with JUnit by Beck and Gamma
(and Beck's previous framework SUnit for Smalltalk). However, EUnit uses
techniques more adapted to functional and concurrent programming, and is
typically less verbose than its relatives.

Although EUnit uses many preprocessor macros, they have been designed to
be as nonintrusive as possible, and should not cause conflicts with
existing code. Adding EUnit tests to a module should thus not normally
require modifying code. Furthermore, tests that only excercise the
exported functions of a module can always be placed in a completely
separate module, avoiding any conflicts entirely.

== Unit Testing ==

Unit Testing is testing of individual program "units" in relative
isolation. There is no particular size requirement: a unit can be a
function, a module, a process, or even a whole application, but the most
typical testing units are individual functions or modules. In order to
test a unit, you specify a set of individual tests, set up the smallest
necessary environment for being able to run those tests (often, you
don't need to do any setup at all), you run the tests and collect the
results, and finally you do any necessary cleanup so that the test can
be run again later. A Unit Testing Framework tries to help you in each
stage of this process, so that it is easy to write tests, easy to run
them, and easy to see which tests failed (so you can fix the bugs).

=== Advantages of unit testing ===

<dl>
  <dt>Reduces the risks of changing the program</dt>
  <dd>Most programs will be modified during their lifetime: bugs will be
  fixed, features will be added, optimizations may become necessary, or
  the code will need to be refactored or cleaned up in other ways to
  make it easier to work with. But every change to a working program is
  a risk of introducing new bugs - or reintroducing bugs that had
  previously been fixed. Having a set of unit tests that you can run
  with very little effort makes it easy to know that the code still
  works as it should (this use is called <em>regression testing</em>;
  see {@section Terminology}). This goes a long way to reduce the
  resistance to changing and refactoring code.</dd>
  <dt>Helps guide and speed up the development process</dt>
  <dd>By focusing on getting the code to pass the tests, the programmer
  can become more productive, not overspecify or get lost in premature
  optimizations, and create code that is correct from the very beginning
  (so-called <em>test-driven development</em>; see {@section
  Terminology}).</dd>
  <dt>Helps separate interface from implementation</dt>
  <dd>When writing tests, the programmer may discover dependencies
  (in order to get the tests to run) that ought not to be there, and
  which need to be abstracted away to get a cleaner design. This helps
  eliminate bad dependencies before they spread throughout the
  code.</dd>
  <dt>Makes component integration easier</dt>
  <dd>By testing in a bottom-up fashion, beginning with the smallest
  program units and creating a confidence in that they work as they
  should, it becomes easier to test that a higher-level component,
  consisting of several such units, also behaves according to
  specification (known as <em>integration testing</em>; see {@section
  Terminology}).</dd>
  <dt>Is self-documenting</dt>
  <dd>The tests can be read as documentation, typically showing both
  examples of correct and incorrect usage, along with the expected
  consequences.</dd>
</dl>

== Terminology ==

<dl>
  <dt>Unit testing</dt>
  <dd>Testing that a program unit behaves as it is supposed to do (in
  itself), according to its specifications. Unit tests have an important
  function as regression tests, when the program later is modified for
  some reason, since they check that the program still behaves according
  to specification.</dd>
  <dt>Regression testing</dt>
  <dd>Running a set of tests after making changes to a program, to check
  that the program behaves as it did before the changes (except, of
  course, for any intentional changes in behaviour). Unit tests are
  important as regression tests, but regression testing can involve more
  than just unit testing, and may also test behaviour that might not be
  part of the normal specification (such as bug-for-bug-compatibility).
  </dd>
  <dt>Integration testing</dt>
  <dd>Testing that a number of individually developed program units
  (assumed to already have been separately unit tested) work together as
  expected. Depending on the system being developed, integration testing
  may be as simple as "just another level of unit testing", but might
  also involve other kinds of tests (compare <em>system testing</em>).
</dd>
  <dt>System testing</dt>
  <dd>Testing that a complete system behaves according to its
  specification. Specifically, system testing should not require knowing
  any details about the implementation. It typically involves testing
  many different aspects of the system behaviour apart from the basic
  functionality, such as performance, usability, and reliability.</dd>
  <dt>Test-driven development</dt>
  <dd>A program development technique where you continuously write tests
  <em>before</em> you implement the code that is supposed to pass those
  tests. This can help you focus on solving the right problems, and not
  make a more complicated implementation than necessary, by letting the
  unit tests determine when a program is "done": if it fulfils its
  specifications, there is no need to keep adding functionality.</dd>
  <dt>Mock object</dt>
  <dd>Sometimes, testing some unit `A' (e.g., a function) requires that
  it collaborates somehow with some other unit `B' (perhaps being passed
  as an argument, or by reference) - but `B' has not been implemented
  yet. A "mock object" - an object which, for the purposes of testing
  `A', looks and behaves like a real `B' - might then be used instead.
  (This is of course only useful if it would be significantly more work
  to implement a real `B' than to create a mock object.)</dd>
  <dt>Test case</dt>
  <dd>A single, well-defined test, that somehow can be uniquely
  identified. When executed, the test case either <em>passes</em> or
  <em>fails</em>; the test report should identify exactly which test
  cases failed.</dd>
  <dt>Test suite</dt>
  <dd>A collection of test cases, generally with a specific, common
  target for testing, such as a single function, module, or subsystem. A
  test suite may also be recursively composed by smaller test
  suites.</dd>
</dl>

== Getting started ==

=== Including the EUnit header file ===

The simplest way to use EUnit in an Erlang module is to add the
following line at the beginning of the module (before any function
definitions, but after all other module-level declarations such as
`-module', `-export', and `-import' declarations:
```-include_lib("eunit/include/eunit_test.hrl").'''

This will have the following effect:
<ul>
  <li>Creates an exported function `test()' (unless testing is turned
  off), that can be used to run all the unit tests defined in the
  module</li>
  <li>Causes all functions whose names match `..._test()' or `..._test_()'
  to be automatically exported from the module (unless testing is
  turned off)</li>
  <li>Makes all the preprocessor macros of EUnit available, to help
  writing tests</li>
</ul>

=== Writing simple test functions ===

The EUnit framework makes it extremely easy to write unit tests in
Erlang. There are a few different ways of writing them, though, so we
start with the simplest:

A function with a name ending in `..._test()' is recognized by EUnit as
a simple test function - it takes no arguments, and its execution either
succeeds (returning some arbitrary value that EUnit will throw away), or
fails by throwing an exception of some kind (or by not terminating, in
which case it will be aborted after a while).

An example of a simple test function could be the following:
```reverse_test() -> lists:reverse([1,2,3]).'''
This just tests that the function `lists:reverse(List)' does not crash
when `List' is `[1,2,3]'. It is not a great test, but many people write
simple functions like this one to test the basic functionality of their
code, and those tests can be used directly by EUnit, without changes,
as long as their function names match.

==== Use exceptions to signal failure ====

To write more interesting tests, we need to make them crash (throw an
exception) when they don't get the result they expect. A simple way of
doing this is to use pattern matching with `=', as in the following
examples:
```reverse_nil_test() -> [] = lists:reverse([]).
   reverse_one_test() -> [1] = lists:reverse([1]).
   reverse_two_test() -> [2,1] = lists:reverse([1,2]).
'''
If there was some bug in `lists:reverse/1' that made it return something
other than `[2,1]' when it got `[1,2]' as input, then the last test
above would throw a `badmatch' error. The first two (we assume they do
not get a `badmatch') would simply return `[]' and `[1]', respectively,
so both succeed. (Note that EUnit is not psychic: if you write a test
that returns a value, even if it is the wrong value, EUnit will consider
it a success. You must make sure that the test is written so that it
causes a crash if the result is not what it should be.)

==== Using assert macros ====

If you want to use Boolean operators for your tests, the `assert'
macro comes in handy (see {@section EUnit macros} for details):
```length_test() -> ?assert(length([1,2,3]) == 3).'''
The `?assert(Expression)' macro will evaluate `Expression', and if that
does not evaluate to `true', it will throw an exception; otherwise it
just returns `ok'. In the above example, the test will thus fail if the
call to `length' does not return 3.

=== Writing test generating functions ===

A drawback of simple test functions is that you must write a separate
function (with a separate name) for each test case. A more compact way
of writing tests (and much more flexible, as we shall see), is to write
functions that <em>return</em> tests, instead of <em>being</em> tests.

A function with a name ending in `..._test_()' (note the final
underscore) is recognized by EUnit as a <em>test generator</em>
function. Test generators return a <em>representation</em> of a <em>set
of tests</em> to be executed by EUnit.

==== Representing a test as data ====

The most basic representation of a test is a single fun-expression that
takes no arguments. For example, the following test generator:
```basic_test_() ->
       fun () -> ?assert(1 + 1 == 2) end.'''
will have the same effect as the following simple test:
```simple_test() ->
       ?assert(1 + 1 == 2).'''
(in fact, EUnit will handle all simple tests just like it handles
fun-expressions: it will put them in a list, and run them one by one).

==== Using macros to write tests ====

To make tests more compact and readable, as well as automatically add
information about the line number in the source code where a test
occurred (and reduce the number of characters you have to type), you can
use the `_test' macro (note the initial underscore character), like
this:
```basic_test_() ->
       ?_test(?assert(1 + 1 == 2)).'''
The `_test' macro takes any expression (the "body") as argument, and
places it within a fun-expression (along with some extra information).
The body can be any kind of test expression, just like the body of a
simple test function.

==== Underscore-prefixed macros create test objects ====

But this example can be made even shorter! Most test macros, such as the
family of `assert' macros, have a corresponding form with an initial
underscore character, which automatically adds a `?_test(...)' wrapper.
The above example can then simply be written:
```basic_test_() ->
       ?_assert(1 + 1 == 2).'''
which has exactly the same meaning (note the `_assert' instead of
`assert'). You can think of the initial underscore as signalling
<em>test object</em>.


=== Disabling testing ===

Testing can be turned off by defining the `NOTEST' macro when compiling,
for example as an option to `erlc', as in:
```erlc -DNOTEST my_module.erl'''
or by adding a macro definition to the code, <em>before any EUnit header
file is included</em>:
```-define(NOTEST, 1).'''
(the value is not important, but should typically be 1 or `true').


== EUnit macros ==

Although all the functionality of EUnit is avaliable even without the
use of preprocessor macros, the EUnit header files define a number of
such macros in order to make it as easy as possible to write unit tests
as compactly as possible and without getting too many details in the
way.

=== Compilation control macros ===

<dl>
<dt>`EUNIT'</dt>
<dd>This macro is always defined to `true' whenever EUnit is enabled at
compile time. This is typically used to place testing code within
conditional compilation, as in:
```-ifdef(EUNIT).
       % test code here
       ...
   -endif.'''
e.g., in order to eliminate compiler warnings about unused functions
when testing is turned off. See also the macros `TEST' and `NOTEST'.
</dd>
<dt>`TEST'</dt>
<dd>This macro is always defined (to `true', unless previously defined
by the user to have another value) whenever EUnit is enabled at compile
time. This can be used to place testing code within conditional
compilation; see also the macros `NOTEST' and `EUNIT'.

For testing code that is strictly dependent on EUnit, it may be
preferable to use the `EUNIT' macro for this purpose, while for code
that uses more generic testing conventions, using the `TEST' macro may
be preferred.

The `TEST' macro can also be used to override the `NOTEST' macro. If
`TEST' is defined <em>before</em> any of the EUnit header files are
included (even if `NOTEST' is also defined), then the code will be
compiled with EUnit enabled.
</dd>
<dt>`NOTEST'</dt>
<dd>This macro is always defined (to `true', unless previously defined
by the user to have another value) whenever EUnit is <em>disabled</em>
at compile time. (Compare the `TEST' macro.)

This macro can also be used for conditional compilation, but is more
typically used to disable testing: If `NOTEST' is defined
<em>before</em> any of the EUnit header files are included, and `TEST'
is <em>not</em> defined, then the code will be compiled with EUnit
disabled.
</dd>
</dl>

=== Utility macros ===

<dl>
<dt>`assert(BoolExpr)'</dt>
<dd>Evaluates the expression `BoolExpr', if testing is enabled. Unless
the result is `true', an informative exception will be generated. If
evaluation completes normally, the result of the macro expression is the
atom `ok', regardless of the value of `BoolExpr'. If testing is
disabled, the macro will not generate any code except the atom `ok', and
`BoolExpr' will not be evaluated.

Typical usage:
```?assert(f(X, Y) == [])'''

The `assert' macro can be used anywhere in a program, not just in unit
tests, to check pre/postconditions and invariants. For example:
```some_recursive_function(X, Y, Z) ->
       ?assert(X + Y > Z),
       ...'''
</dd>
<dt>`assertMatch(GuardedPattern, Expr)'</dt>
<dd>Evaluates `Expr' and matches the result against `GuardedPattern', if
testing is enabled. If the match fails, an informative exception will be
generated; see the `assert' macro for further details. `GuardedPattern'
can be anything that you can write on the left hand side of the `->'
symbol in a case-clause, except that it cannot contain comma-separated
guard tests.

The main reason for using `assertMatch' also for simple matches, instead
of matching with `=', is that it produces more detailed error messages.

Examples:
```?assertMatch({found, {fred, _}}, lookup(bloggs, Table))'''
```?assertMatch([X|_] when X > 0, binary_to_list(B))'''
</dd>
<dt>`assertException(ClassPattern, TermPattern, Expr)'</dt>
<dt>`assertError(TermPattern, Expr)'</dt>
<dt>`assertExit(TermPattern, Expr)'</dt>
<dt>`assertThrow(TermPattern, Expr)'</dt>
<dd>Evaluates `Expr', catching any exception and testing that it matches
the expected `ClassPattern:TermPattern'. If the match fails, or if no
exception is thrown by `Expr', an informative exception will be
generated; see the `assert' macro for further details. The
`assertError', `assertExit', and `assertThrow' macros, are equivalent to
using `assertException' with a `ClassPattern' of `error', `exit', or
`throw', respectively.

Examples:
```?assertError(badarith, X/0)'''
```?assertExit(foo, exit(foo))'''
```?assertException(throw, {foo, _}, throw({foo, 42}))'''
</dd>

</dl>
